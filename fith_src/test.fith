\ simple tests
3 8 + 11 != if "math error" p then

\ multi line string
"
Hello 
World!
" p 

7 6 8 9 drop drop drop drop 

\ test if else chain, use random
random abs 3 &
dup 0 == if
	"zero" p
else dup 1 == if
	"one" p
else dup 2 == if
	"two" p
else dup 3 == if
	"three" p
then then then then
drop

\ regular funtions with a loop test
divisibleBy5?: dup 5 % ! ;
divisibleBy3?: dup 3 % ! ;

0 10
begin
	1 -
	divisibleBy5? \ true if multiple of 5
	if 
		swap over + swap
	else  
		divisibleBy3? \ true if multiple of 3
		if 
			swap over + swap
		then
	then
	
	dup 1 ==
until
drop 23 != if "3 and 5 test faillure" p then

5.5 6.3 f+ 11.8 != if "floating point is not equal" p then

\ child function to send message, read message from parent and send done
childSend: $chan1 "Hello, parent!" writes "finished sending msg to parent" p 
$chan1 $buf 128 reads "From Parent:" p p 
$chan1 "done" writes ;

\ prepare for transfer, need to add close word
chan =$chan1 =$chan0 \ take up channel file descriptors
128 malloc =$buf \ create and save buffer
childSend@ fork =$pid \ create child process save off pid
$chan0 $buf 128 reads "From child:" p p \ read message from child
$chan0 "Hello, child!" writes "finished sending msg to child" p \send message 2 child
$chan0 $buf 128 reads "done" 5 memcmp 0 != if "message not expected" then \ read message from child

\ if else check
 1 if 
	"If true" p
else 
	"ERROR1" p
	 1 if 
		"ERROR2" p 
	else 
		"ERROR3" p 
	then 
	"ERROR4" p
	1 if
	"ERROR5" p
	then
	0 if
		9
	else
		1 if
			"ERROR6" p
		else
			"ERROR7" p
		then
	then
then 
"Always" p 

\ loop factorial
5 0 swap                           \ place a zero below n
  begin dup 1 - dup 1 == until     \ make stack like 0 n ... 4 3 2 1
  begin * over 0 == until     \ multiply till see the zero below answer
  swap drop 120 != if "loop factorial fail" then

\ recursive factorial
fact: 
	dup 1 > if                     \ if 1 (or 0) \just leave on stack
		dup 1 - fact               \ next number down - get its factorial
		 * then                     \ and mult - leavin ans on stack
;

5 fact 120 != if "recursive factorial fail" then

\ variable overwrite
220 =$num .
22 =$bum
55 =$fum
$num $bum $fum + + =$fum $fum
=$num $num 297 != if "variable overwite fail" then

\ json input addr, string key, value, typed function, suck up pointer, output and print 
"{}" ".type" "bear" json_set_s =$json1 $json1 p
$json1 ".numFeet" 2   json_set_i =$json1 $json1 p
$json1 ".weight" 7.8  json_set_d =$json1 $json1 p

\ json input addr, string key, value, typed function, suck up pointer, output and print 
"[]" "[0]" "bear" json_set_s =$json2 $json2 p
$json2 "[1]" 2      json_set_i =$json2 $json2 p
$json2 "[2]" 7.8    json_set_d =$json2 $json2 p $json2 json_array_len
3 != if "array length error" then

$json1 ".info" $json2 json_set_j =$json1 $json1 p $json1 ".info[0]" json_extract p.
( "{\"type\":\"bear\",\"numFeet\":2,\"weight\":7.8,\"info\":[\"bear\",2,7.8]}"
63 memcmp 0 != if "ERROR JSON not expected" then )

















