\ simple tests
\debug
first_test: 3 8 + 11 != if 'math error' p then ;

\ multi line string
'
Hello 
World!
' p 

7 6 8 9 drop drop drop drop 

\ test if else chain, use random
random_if_else:
	random abs 3 &
	dup 0 == if
		'zero' p
	else dup 1 == if
		'one' p
	else dup 2 == if
		'two' p
	else 3 == if
		'three' p
	then then then then
;


\ regular funtions with a loop test
divisibleBy5?: dup 5 % not ;
divisibleBy3?: dup 3 % not ;

factors_of:
	0 10
	begin
		1 -
		divisibleBy5? \ true if multiple of 5
		if 
			swap over + swap
		else  
			divisibleBy3? \ true if multiple of 3
			if 
				swap over + swap
			then
		then
		
		dup 1 ==
	until
	drop 23 != if '3 and 5 test faillure' p then
;

floating?: 5.5 6.3 f+ 11.8 != if 'floating point is not equal' p then ;

\ child function to send message, read message from parent and send done
childSend:
	$chan1 'Hello, parent!' writes 'finished sending msg to parent' p 
	$chan1 $buf 128 reads 'From Parent:' p p 
	$chan1 'done' writes 
;

fork_and_talk:
	\ prepare for transfer, need to add close word
	chan =$chan1 =$chan0 \ take up channel file descriptors
	128 malloc =$buf \ create and save buffer
	childSend@ fork =$pid \ create child process save off pid
	$chan0 $buf 128 reads 'From child:' p p \ read message from child
	$chan0 'Hello, child!' writes 'finished sending msg to child' p \send message 2 child
	$chan0 $buf 128 reads 'done' 5 memcmp 0 != if 'message not expected' then \ read message from child
;
if_else_chain:
\ if else check
 1 if 
	'If true' p
else 
	'ERROR1' p
	 1 if 
		'ERROR2' p 
	else 
		'ERROR3' p 
	then 
	'ERROR4' p
	1 if
	'ERROR5' p
	then
	0 if
		9
	else
		1 if
			'ERROR6' p
		else
			'ERROR7' p
		then
	then
then 
'Always' p 
;

\ loop factorial
5 0 swap                           \ place a zero below n
  begin dup 1 - dup 1 == until     \ make stack like 0 n ... 4 3 2 1
  begin * over 0 == until     \ multiply till see the zero below answer
  swap drop 120 != if 'loop factorial fail' then

\ recursive factorial
fact: 
	dup 1 > if                     \ if 1 (or 0) \just leave on stack
		dup 1 - fact               \ next number down - get its factorial
		 * then                     \ and mult - leavin ans on stack
;

5 fact 120 != if 'recursive factorial fail' then

\ variable overwrite
220 =$num .
22 =$bum
55 =$fum
$num $bum $fum + + =$fum $fum
=$num $num 297 != if 'variable overwite fail' then

JSON_regression_test:
	\ json input addr, string key, value, typed function, suck up pointer, output and print 
	'{}' '.type' 'bear' json_set_s =$json1 $json1 p
	$json1 '.numFeet' 2   json_set_i =$json1 $json1 p
	$json1 '.weight' 7.8  json_set_d =$json1 $json1 p

	\ json input addr, string key, value, typed function, suck up pointer, output and print 
	'[]' '[0]' 'bear' json_set_s =$json2 $json2 p
	$json2 '[1]' 2      json_set_i =$json2 $json2 p
	$json2 '[2]' 7.8    json_set_d =$json2 $json2 p $json2 json_array_len
	3 != if 'array length error' then

	$json1 '.info' $json2 json_set_j =$json1 $json1 p $json1 '.info[0]' json_extract p.
	( '{\'type\':\'bear\',\'numFeet\':2,\'weight\':7.8,\'info\':[\'bear\',2,7.8]}'
	63 memcmp 0 != if 'ERROR JSON not expected' then )


	'special' =$jsonObj.type.s $jsonObj p
	'green' =$jsonObj.color.s $jsonObj p
	'Ham sandwich' =$jsonObj.lunch.s $jsonObj p
	5 =$jsonObj.num.i $jsonObj p
	53.5 =$jsonObj.numpy.d $jsonObj p
	$json2 =$jsonObj.animal.j $jsonObj p
	67 =$jsonObj.animal[3].i $jsonObj p \ add to array value of key animal
	$jsonObj.animal[3] . drop
	$jsonObj.animal p
	$jsonObj p

	5 4 3 2 1 =$jsonAr[#].i 
	=$jsonAr[#].i 
	=$jsonAr[#].i 
	=$jsonAr[#].i =$jsonAr[#].i 'done' =$jsonAr[#].s $jsonAr p
	'[1,2,3,4,5]' . jeach jdone . clear
	'[1.0,2.0,3.0,4.0,5.0]' jeach jdone f. clear 
	'[[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5]]' jeach jeach jdone jdone . clear
	'{"bob":"john","bob1":"john","bob2":"john","bob4":"john"}'  jeach jdone p p p p


	\'1' =$jsonAr2[#].s $jsonAr2 p
	'a' 'v' 'd' 'f' 'd' dep . =$jsonAr2[?].s $jsonAr2 p

	1 2 3 4 5 dep . =$jsonAr3[?].i $jsonAr3 p $jsonAr3 jeach jdone . clear
	 
	0 =$var.key.i $var p . 'test' p $var[aa] . p

	\'fith_src/script.fith' load

	5 4 3 2 1 dep . =$jsonAr4[?].i $jsonAr4 dup p jsort p
	'p' 'a' 'h' 'j' 'w' 'Z' '100' '9' dep =$jsonAr5[?].s $jsonAr5 dup p jsort p
	5.5 6.6 1.0 3.3 99.6 dep =$jsonAr6[?].d $jsonAr6 dup p jsort p

;


indexInc: $index dup 1 + =$index ;

0   =$index
5   =$matrix
200 =$sizeOfMatrix

$sizeOfMatrix $sizeOfMatrix * . array =$matrix

\ set array [5] to 10
10 5 =$matrix[]

\ what is at array[5]? put on stack
5 $matrix[] . drop
.
\GC
'[0]' s2o dup p =$IONarray

\~ 0
\~ begin
	\~ dup =$cart1[#].i
	\~ 1 +
	\~ dup $sizeOfMatrix ==
\~ until
\~ drop
\~ $cart1 . 
\~ jeach  \first val on stack .
	\~ $cart1 
	\~ jeach 
		 \~ over * $IONarray '[#]' ion-set-i ( dup p ) =$IONarray \=$cart2[#].i \indexInc =$matrix[] \ $IONarray '[#]' ion-set-i ( dup p ) =$IONarray
	\~ jdone
	\~ drop \GC
\~ jdone

\~ \'hello' praw
\~ 55  =$jsonObj.age.i
\~ 1  =$jsonObj.dogs.i
\~ 7.864 =$jsonObj.height.d
\~ '["yoyo","hello motto"]' =$jsonObj.favs.j
\~ '{"circuit":"breaker","pencil":"broken"}' =$jsonObj.inBox.j
\~ 'special' =$jsonObj.type.s $jsonObj p

\~ $jsonObj s2o p
\~ \$jsonObj s2o search
\~ $jsonObj s2o '.type' ion-get p
 \~ $jsonObj s2o '.age' ion-get . drop
\~ $jsonObj s2o '.height' ion-get f. drop
 \~ $jsonObj s2o '.favs' ion-get dup p 0 swap . '[]' ion-get p
 \~ $jsonObj s2o '.inBox' ion-get p
 \~ $jsonObj s2o '.inBox' ion-get 'hammer' swap '.tool' ion-set-s dup p

 \~ 'screw' swap '.tool' ion-set-s dup p .
 \~ 55 swap '.tool' ion-set-i dup p

'[0,1,2,[0,1,2,3,4,5,6,7,8,9],4,5,6,7,8,9]' s2o dup p =$IONarraytest
3 3 55 '[][]' $IONarraytest ion-set-i dup p =$IONarraytest
3 77 '[][#]' $IONarraytest ion-set-i dup p =$IONarraytest
3 'hello' '[][#]' $IONarraytest ion-set-s dup p =$IONarraytest
3 7.68 '[][#]' $IONarraytest ion-set-d dup p =$IONarraytest
2 '{"color":"green"}' s2o '[]' $IONarraytest ion-set-o dup p =$IONarraytest



\=$cart2[#].i

\~ .
\~ : 'hello from anon function' p ; call

\ $cart2 p
\ 1 2 3 4 5 depth =$var[?].i puts it all into array
 \~ \## REQUEST FOR COMMENT
\~ jeach \ goes once per element in array, pushes JSON value onto stack
	\~ ( value is on top of the stack )
	\~ ( do stuffs )
\~ jdone
\~ jeach \ goes once per element in array
	\~ 5 2.2 
	\~ jeach.a ( this pushes value on stack )
\~ jdone

\~ jeach
	\~ jeach.a 
	\~ jeach
		\~ jeach.b
	\~ jdone
\~ jdone



		( x1 x2 x3 -- )
		( #var1=x1 #var2=x2 #var3=x3 )
\~ fact: { #var1 #var2 #var3 } 
	\~ dup 1 > if                     \ if 1 (or 0) \just leave on stack
		\~ dup 1 - fact               \ next number down - get its factorial
		 \~ * then                     \ and mult - leavin ans on stack
\~ ;











