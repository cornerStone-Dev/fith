3 8 + .
"Hello World! 
Continued 
Mary had a little lamb!!" p drop 7 6 8 9 drop drop drop drop "test overwrite" p

7 6 8 9 drop drop drop drop 

buzz:   5 % 0 == if "Buzz" p else  "Silence"  p then ;

1 2 random abs . drop drop drop .

3 buzz
4 buzz
5 buzz

\exit

divisibleBy5?: dup 5 % ! ;
divisibleBy3?: dup 3 % ! ;

0 10
begin
	1 -
	divisibleBy5? \ true if multiple of 5
	if 
		swap over + swap
	else  
		divisibleBy3? \ true if multiple of 3
		if 
			swap over + swap
		then
	then
	.
	dup 1 ==
until
drop . drop

5.5 6.3 f+ 7.7 f. drop drop .

childSend: $chan1 "Hello, parent!" writes "finished sending msg" p 
$chan1 $buf 128 reads "Child:" p p 
$chan1 "done" writes ;

\ prepare for transfer, need to add close word

chan =$chan1 =$chan0 \ take up channel file descriptors
128 malloc =$buf \ create and save buffer
childSend@ fork =$pid \ create child process save off pid
$chan0 $buf 128 reads "Parent:" p p .
$chan0 "Hello, child!" writes "finished sending msg to child" p
$chan0 $buf 128 reads drop

\ create empty json object, output address and print
=$json1.jo $json1 . p 

\ json input addr, string key, value, typed function, suck up pointer, output and print 
$json1 ".type" "bear" json_set_s =$json1 $json1 p
$json1 ".numFeet" 2   json_set_i =$json1 $json1 p
$json1 ".weight" 7.8  json_set_d =$json1 $json1 p

\ create empty json array, output address and print
=$json2.ja $json2 . p 

\ json input addr, string key, value, typed function, suck up pointer, output and print 
$json2 "[0]" "bear" json_set_s =$json2 $json2 p
$json2 "[1]" 2      json_set_i =$json2 $json2 p
$json2 "[2]" 7.8    json_set_d =$json2 $json2 p $json2 json_array_len .

$json1 ".info" $json2 json_set_j =$json1 $json1 p

\1 0 sleep debug 7 8 9 drop drop drop

\~ 0 10
\~ begin
	\~ 1 -
	\~ dup 5 % ! \ true if multiple of 5
	\~ if 
		\~ dup
	\~ else  
		\~ dup 3 % ! \ true if multiple of 3
		\~ if 
			\~ dup
		\~ then
	\~ then
	\~ .
	\~ dup 1 ==
\~ until
\~ drop .


 \~ 1 if 
	\~ "If true" p
\~ else 
	\~ "Else" p
	 \~ 1 if 
		\~ "Else if" p 
	\~ else 
		\~ "Else Else" p 
	\~ then 
	\~ "then?" p
	\~ 1 if
	\~ "yes" p
	\~ then
	\~ 0 if
		\~ 9
	\~ else
		\~ 1 if
			\~ "wow this is deep" p
		\~ else
			\~ "tricky!" p
		\~ then
	\~ then
\~ then 
\~ "Always\n" p drop 

\~ 5 0 swap                           \ place a zero below n
  \~ begin dup 1 - dup 1 == until     \ make stack like 0 n ... 4 3 2 1
  \~ begin . * over 0 == until     \ multiply till see the zero below answer
  \~ swap drop . drop

\~ fact: 
	\~ dup 1 > if                     \ if 1 (or 0) \just leave on stack
		\~ dup 1 - fact               \ next number down - get its factorial
		\~ . * then                     \ and mult - leavin ans on stack
\~ ;

\~ 5 fact .

\~ buzz:   5 % 0 == if "Buzz" p else  "Silence"  p then ;

\~ 3 buzz
\~ 4 buzz
\~ 5 buzz

\~ 5 5 % 0 == if "Buzz" p else "silence" p then .

\~ 220 =$num .
\~ 22 =$bum
\~ 55 =$fum
\~ $num $bum $fum . + . + . =$fum $fum . "test overwrite" p
\~ =$num $num .


\~ fact_sleep:  
	 \~ "inside fact_sleep" p dup 1 > if                     \ if 1 (or 0) just leave on stack
		\~ dup 1 - fact_sleep               \ next number down - get its factorial
		\~ . * 1 0 sleep then .                     \ and mult - leavin ans on stack
\~ ;
\~ "Forking!!!" p 5 5 5 
\~ 6 . drop "begin" p . "end" p fact_sleep@ fork =$pid "Hello From" p $pid . drop 6 . fact_sleep 13 0 sleep "Parent leaving" p .\ fact_sleep
\~ 5 fact_sleep@ fork =$pid
\~ 5 fact_sleep@ fork =$pid
\~ 5 fact_sleep@ fork =$pid
\~ 5 fact_sleep@ fork =$pid
\~ 5 fact_sleep@ fork =$pid
\~ 5 fact_sleep@ fork =$pid
\~ 13 0 sleep



















