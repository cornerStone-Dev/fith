\ simple tests
3 8 + 11 != if 'math error' p then

\ multi line string
'
Hello 
World!
' p 

7 6 8 9 drop drop drop drop 

\ test if else chain, use random
random abs 3 &
dup 0 == if
	'zero' p
else dup 1 == if
	'one' p
else dup 2 == if
	'two' p
else dup 3 == if
	'three' p
then then then then
drop

\ regular funtions with a loop test
divisibleBy5?: dup 5 % ! ;
divisibleBy3?: dup 3 % ! ;

0 10
begin
	1 -
	divisibleBy5? \ true if multiple of 5
	if 
		swap over + swap
	else  
		divisibleBy3? \ true if multiple of 3
		if 
			swap over + swap
		then
	then
	
	dup 1 ==
until
drop 23 != if '3 and 5 test faillure' p then

5.5 6.3 f+ 11.8 != if 'floating point is not equal' p then

\ child function to send message, read message from parent and send done
childSend: $chan1 'Hello, parent!' writes 'finished sending msg to parent' p 
$chan1 $buf 128 reads 'From Parent:' p p 
$chan1 'done' writes ;

\ prepare for transfer, need to add close word
chan =$chan1 =$chan0 \ take up channel file descriptors
128 malloc =$buf \ create and save buffer
childSend@ fork =$pid \ create child process save off pid
$chan0 $buf 128 reads 'From child:' p p \ read message from child
$chan0 'Hello, child!' writes 'finished sending msg to child' p \send message 2 child
$chan0 $buf 128 reads 'done' 5 memcmp 0 != if 'message not expected' then \ read message from child

\ if else check
 1 if 
	'If true' p
else 
	'ERROR1' p
	 1 if 
		'ERROR2' p 
	else 
		'ERROR3' p 
	then 
	'ERROR4' p
	1 if
	'ERROR5' p
	then
	0 if
		9
	else
		1 if
			'ERROR6' p
		else
			'ERROR7' p
		then
	then
then 
'Always' p 

\ loop factorial
5 0 swap                           \ place a zero below n
  begin dup 1 - dup 1 == until     \ make stack like 0 n ... 4 3 2 1
  begin * over 0 == until     \ multiply till see the zero below answer
  swap drop 120 != if 'loop factorial fail' then

\ recursive factorial
fact: 
	dup 1 > if                     \ if 1 (or 0) \just leave on stack
		dup 1 - fact               \ next number down - get its factorial
		 * then                     \ and mult - leavin ans on stack
;

5 fact 120 != if 'recursive factorial fail' then

\ variable overwrite
220 =$num .
22 =$bum
55 =$fum
$num $bum $fum + + =$fum $fum
=$num $num 297 != if 'variable overwite fail' then

\ json input addr, string key, value, typed function, suck up pointer, output and print 
'{}' '.type' 'bear' json_set_s =$json1 $json1 p
$json1 '.numFeet' 2   json_set_i =$json1 $json1 p
$json1 '.weight' 7.8  json_set_d =$json1 $json1 p

\ json input addr, string key, value, typed function, suck up pointer, output and print 
'[]' '[0]' 'bear' json_set_s =$json2 $json2 p
$json2 '[1]' 2      json_set_i =$json2 $json2 p
$json2 '[2]' 7.8    json_set_d =$json2 $json2 p $json2 json_array_len
3 != if 'array length error' then

$json1 '.info' $json2 json_set_j =$json1 $json1 p $json1 '.info[0]' json_extract p.
( '{\'type\':\'bear\',\'numFeet\':2,\'weight\':7.8,\'info\':[\'bear\',2,7.8]}'
63 memcmp 0 != if 'ERROR JSON not expected' then )


'special' =$jsonObj.type.s $jsonObj p
'green' =$jsonObj.color.s $jsonObj p
'Ham sandwich' =$jsonObj.lunch.s $jsonObj p
5 =$jsonObj.num.i $jsonObj p
53.5 =$jsonObj.numpy.d $jsonObj p
$json2 =$jsonObj.animal.j $jsonObj p
67 =$jsonObj.animal[3].i $jsonObj p \ add to array value of key animal
$jsonObj.animal[3] . drop
$jsonObj.animal p
$jsonObj p

5 4 3 2 1 =$jsonAr[#].i 
=$jsonAr[#].i 
=$jsonAr[#].i 
=$jsonAr[#].i =$jsonAr[#].i 'done' =$jsonAr[#].s $jsonAr p
'[1,2,3,4,5]' p











